import{an as J,r as b,ao as j,a as E,b7 as x,b8 as N}from"./index-BgBVt1_Q.js";const S=[],P="KEY_MQTT_CONFIG",k=J("mqtt",()=>{const h=localStorage.getItem(P);let l={url:"",username:"",password:""};if(h)try{l=JSON.parse(h)}catch(t){console.error("Failed to parse saved MQTT config:",t)}const u=b(l),d=b({}),g=b([{label:"",children:[],selectable:!1,id:"__ROOT__"}]);j(()=>{g.value[0].label=u.value.url});function _(t){const n=t.split("/");let e=g.value[0],o=[];n.forEach((m,C)=>{const c=C===n.length-1;if(o.push(m),c&&m==="config"&&n[0]==="homeassistant"){const a=JSON.parse(d.value[t]);a.device.identifiers[0].startsWith("zigbee2mqtt")&&(e.parent.avatar="logos/zigbee2mqtt.png",e.parent.type="zigbee2mqtt",e.type="zigbee2mqtt"),e.parent.header="homeassistant-discovery",e.parent.label=`${a.device.name} - ${a.device.manufacturer} ${a.device.model} [${e.parent.labelPart}]`}if(c&&m==="config"&&n[0]==="tasmota"){const a=JSON.parse(d.value[t]);e.header="tasmota-discovery",e.body="tasmota-discovery",e.device=a}const w=e.children.find(a=>a.labelPart===m);if(w)e=w,c&&(e.selectable=c);else{const a={label:m,labelPart:m,children:[],selectable:c,id:o.join("/"),parent:e,type:e.type};a.id==="zigbee2mqtt"&&(a.avatar="logos/zigbee2mqtt.png",a.type="zigbee2mqtt"),a.id==="homeassistant"&&(a.avatar="logos/homeassistant.svg"),["tasmota","tele","cmnd","stat"].includes(a.id)&&(a.avatar="logos/tasmota.svg"),e.children.push(a),e.children.sort((z,D)=>z.label.localeCompare(D.label)),e=a}})}function T(t){const n=t.split("/");let e=g.value[0];n.forEach((o,m)=>{if(m===n.length-1)for(e.children=e.children.filter(c=>c.id!==t);e.parent;)e.children.length===0&&(e.parent.children=e.parent.children.filter(c=>c.id!==e.id)),e=e.parent;else{const c=e.children.find(w=>w.labelPart===o);c&&(e=c)}})}const f=b(!1),v=b(null);async function q(){localStorage.setItem(P,JSON.stringify(u.value)),v.value=null;try{const t=await window.mqtt.connect({url:u.value.url,username:u.value.username,password:u.value.password},(n,e)=>{if(n===null){Object.prototype.hasOwnProperty.call(e,"connected")&&(f.value=e.connected,f.value&&(v.value=null)),Object.prototype.hasOwnProperty.call(e,"error")&&(v.value=e.error,f.value=!1);return}e?(d.value[n]=e,_(n,e)):(T(n),delete d.value[n]),S.forEach(o=>{n.match(o.topic)&&o.callback(n,e)})});t.success||(v.value=t.error||"Connection failed",f.value=!1)}catch(t){v.value=t.message||"Connection failed",f.value=!1}}function y(t){return Object.keys(d.value).filter(n=>n.match(t))}async function s(){try{await window.mqtt.disconnect(),f.value=!1}catch(t){console.error("Disconnect error:",t)}}async function i(t,n,e={}){try{const o=await window.mqtt.publish(t,n,e);o.success||console.error("Publish failed:",o.error)}catch(o){console.error("Publish error:",o)}}function r(t,n){const e={topic:t,callback:n};return S.push(e),e}function p(t){S.splice(S.indexOf(t),1)}const O=E(()=>y("zigbee2mqtt/").reduce((t,n)=>{const e=n.split("/").slice(0,2).join("/");return t.includes(e)||t.push(e),t},[]).length),$=E(()=>y("homeassistant/").reduce((t,n)=>{const e=n.split("/")[2];return t.includes(e)||t.push(e),t},[]).length);return{config:u,isConnected:f,topics:d,topicsTree:g,zigbee2mqttCount:O,homeassistantCount:$,error:v,connect:q,disconnect:s,publish:i,subscribe:r,unsubscribe:p,searchTopics:y}}),R=J("homeassistant",()=>{const h=k(),l=b([]);function u(s){const i=JSON.parse(JSON.stringify(s.config));return s.entities.map(r=>{const p=JSON.parse(JSON.stringify(r.config));return p.device=i,{topic:`homeassistant/${r.type}/${s.id}/${r.id}/config`,message:JSON.stringify(p,null,2)}})}function d(s){u(s).forEach(({topic:i,message:r})=>{h.publish(i,r,{retain:!0})})}function g(){l.value.forEach(d)}function _(s){const i=`0x${Math.random().toString(36).substring(2,15)}`,r={id:i,config:{identifiers:[`mqtt_${i}`],manufacturer:"",model:"",name:""},entities:[]};l.value.push(s||r)}function T(s,i){const r={type:"sensor",id:"temperature",config:{name:"",state_topic:"",state_class:"measurement",device_class:"temperature",unit_of_measurement:"Â°C",value_template:`{% if value_json.temperature is defined %}
  {{ value_json.temperature }}
{% else %}
  {{ states(entity_id) }}
{% endif %}
`}};i.entities||(i.entities=[]),i.entities.push(s||r)}function f(s){l.value=[];const i={id:s,entities:[]};l.value.push(i),h.searchTopics(new RegExp(`homeassistant/.*/${s}/.*/config`)).forEach(r=>{const p=JSON.parse(h.topics[r]);i.config=p.device,delete p.device;const O=r.split("/");i.entities.push({type:O[1],id:O[3],config:p})}),x.push("/discovery-generator")}function v(){N.create({title:"Confirm",message:"Remove all devices and entities?",cancel:!0,persistent:!0}).onOk(()=>{l.value=[]})}function q(s){N.create({title:"Confirm",message:"Remove device and entities?",cancel:!0,persistent:!0}).onOk(()=>{l.value.splice(l.value.indexOf(s),1)})}function y(s,i){N.create({title:"Confirm",message:"Remove entity?",cancel:!0,persistent:!0}).onOk(()=>{s.entities.splice(s.entities.indexOf(i),1)})}return{devices:l,addDevice:_,addEntityToDevice:T,reverseEntity:f,removeAll:v,removeDevice:q,removeDeviceEntity:y,toDiscoveryEntries:u,publishDevice:d,publishAllDevices:g}});export{R as a,k as u};
